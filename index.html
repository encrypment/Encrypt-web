<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>encrypt</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(20, 20, 35, 0.9);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 0 30px rgba(0, 200, 255, 0.3);
            border: 1px solid #00ccff;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #00ccff;
        }
        
        h1 {
            font-size: 2.8rem;
            margin-bottom: 10px;
            color: #00ccff;
            text-shadow: 0 0 15px rgba(0, 204, 255, 0.7);
        }
        
        .subtitle {
            color: #00a3cc;
            font-size: 1.2rem;
        }
        
        .panel {
            background: rgba(15, 15, 30, 0.9);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid #0066ff;
        }
        
        h2 {
            color: #00ccff;
            margin-bottom: 15px;
            font-size: 1.6rem;
            display: flex;
            align-items: center;
        }
        
        h2::before {
            content: "XIO>";
            color: #0066ff;
            margin-right: 10px;
            font-weight: bold;
        }
        
        textarea {
            width: 100%;
            height: 150px;
            background: #0f0f1f;
            color: #00ffcc;
            border: 1px solid #0066ff;
            border-radius: 8px;
            padding: 15px;
            resize: vertical;
            margin-bottom: 15px;
            font-family: monospace;
            font-size: 14px;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 14px;
            background: #0f0f1f;
            color: #00ffcc;
            border: 1px solid #0066ff;
            border-radius: 8px;
            margin-bottom: 15px;
            font-family: monospace;
        }
        
        .input-group {
            display: flex;
            gap: 15px;
        }
        
        .input-group input {
            flex: 1;
        }
        
        button {
            background: linear-gradient(135deg, #0066ff 0%, #00ccff 100%);
            color: #001133;
            border: none;
            padding: 14px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 102, 255, 0.5);
        }
        
        button:hover {
            background: linear-gradient(135deg, #0055ee 0%, #00bbee 100%);
            transform: translateY(-3px);
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.7);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button:disabled {
            background: #004477;
            color: #0077aa;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .control-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 25px;
        }
        
        .stat-box {
            background: rgba(15, 15, 30, 0.9);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            border: 1px solid #0066ff;
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.3);
        }
        
        .stat-number {
            font-size: 2.2rem;
            font-weight: bold;
            color: #00ccff;
            text-shadow: 0 0 10px rgba(0, 204, 255, 0.5);
        }
        
        .stat-label {
            color: #00a3cc;
            font-size: 0.95rem;
        }
        
        .log-container {
            margin-top: 30px;
        }
        
        #log {
            height: 250px;
            overflow-y: auto;
            background: #0f0f1f;
            color: #00ffcc;
            border: 1px solid #0066ff;
            border-radius: 10px;
            padding: 20px;
            font-family: monospace;
            font-size: 0.95rem;
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 8px;
            border-left: 3px solid #00ccff;
            padding-left: 15px;
            background: rgba(0, 102, 255, 0.1);
            border-radius: 0 5px 5px 0;
        }
        
        .success {
            color: #00ffaa;
            border-left-color: #00ffaa;
            background: rgba(0, 255, 170, 0.1);
        }
        
        .error {
            color: #ff3366;
            border-left-color: #ff3366;
            background: rgba(255, 51, 102, 0.1);
        }
        
        .warning {
            color: #ffcc00;
            border-left-color: #ffcc00;
            background: rgba(255, 204, 0, 0.1);
        }
        
        .info {
            color: #00ccff;
        }
        
        .instructions {
            background: rgba(15, 15, 30, 0.9);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid #0066ff;
        }
        
        .instructions h3 {
            color: #00ccff;
            margin-bottom: 15px;
            font-size: 1.4rem;
        }
        
        .instructions ul {
            padding-left: 25px;
            margin-bottom: 20px;
        }
        
        .instructions li {
            margin-bottom: 10px;
            color: #00a3cc;
        }
        
        .xio-badge {
            display: inline-block;
            background: linear-gradient(135deg, #0066ff 0%, #00ccff 100%);
            color: #001133;
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            margin-right: 10px;
        }
        
        .proxy-manager {
            background: rgba(15, 15, 30, 0.9);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid #0066ff;
        }
        
        .proxy-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .proxy-toggle {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 30px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #004477;
            transition: .4s;
            border-radius: 30px;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .slider {
            background-color: #0066ff;
        }
        
        input:checked + .slider:before {
            transform: translateX(30px);
        }
        
        .proxy-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 15px;
            padding: 10px;
            background: #0f0f1f;
            border-radius: 8px;
            border: 1px solid #0066ff;
        }
        
        .proxy-item {
            padding: 8px;
            margin-bottom: 5px;
            background: rgba(0, 102, 255, 0.1);
            border-radius: 5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .proxy-item:last-child {
            margin-bottom: 0;
        }
        
        .proxy-actions {
            display: flex;
            gap: 5px;
        }
        
        .proxy-actions button {
            padding: 5px 10px;
            font-size: 0.8rem;
        }
        
        @media (max-width: 768px) {
            .input-group {
                flex-direction: column;
            }
            
            .stats {
                grid-template-columns: 1fr 1fr;
            }
            
            h1 {
                font-size: 2.2rem;
            }
            
            .control-buttons {
                flex-direction: column;
            }
        }
        
        @media (max-width: 480px) {
            .stats {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8rem;
            }
            
            .proxy-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Encrypt</h1>
            <p class="subtitle">Token Joiner with Proxy Support</p>
        </header>
        
        <div class="proxy-manager">
            <div class="proxy-header">
                <h2>Proxy Management</h2>
                <div class="proxy-toggle">
                    <span>Use Proxies:</span>
                    <label class="switch">
                        <input type="checkbox" id="proxyToggle">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>
            
            <p>Add proxies in format: IP:PORT or IP:PORT:USERNAME:PASSWORD (one per line)</p>
            <textarea id="proxies" placeholder="192.168.1.1:8080
192.168.1.2:8080:user:pass
193.122.1.5:3128"></textarea>
            
            <div class="control-buttons">
                <button id="saveProxiesBtn">Save Proxies</button>
                <button id="clearProxiesBtn">Clear Proxies</button>
                <button id="testProxiesBtn">Test Proxies</button>
            </div>
            
            <div id="proxyList" class="proxy-list" style="display: none;">
                <h3>Saved Proxies</h3>
                <div id="proxyItems"></div>
            </div>
        </div>
        
        <div class="panel">
            <h2>Tokens Input</h2>
            <p>Enter one authentication token per line</p>
            <textarea id="tokens" placeholder="phuk uu"></textarea>
            
            <h2>Server Invite</h2>
            <p>Enter server invite code or URL</p>
            <div class="input-group">
                <input type="text" id="inviteCode" placeholder="list.bot/example or https://lust.bot/example">
            </div>
            
            <div class="control-buttons">
                <button id="startBtn">Start Joining</button>
                <button id="clearBtn">Clear Log</button>
                <button id="testBtn">Test Connection</button>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-box">
                <div class="stat-number" id="totalTokens">0</div>
                <div class="stat-label">Total Tokens</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="successCount">0</div>
                <div class="stat-label">Successful Joins</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="failCount">0</div>
                <div class="stat-label">Failed Joins</div>
            </div>
            <div class="stat-box">
                <div class="stat-number" id="captchaCount">0</div>
                <div class="stat-label">CAPTCHA Errors</div>
            </div>
        </div>
        
        <div class="log-container">
            <h2>Activity Log</h2>
            <div id="log"></div>
        </div>
        
        <div class="instructions">
            <h3>How to use this Server Joiner with Proxies</h3>
            <ul>
                <li><span class="xio-badge">1</span> Add your proxies in IP:PORT format (with auth if needed)</li>
                <li><span class="xio-badge">2</span> Toggle "Use Proxies" to enable proxy support</li>
                <li><span class="xio-badge">3</span> Paste your authentication tokens</li>
                <li><span class="xio-badge">4</span> Enter a valid server invite code or URL</li>
                <li><span class="xio-badge">5</span> Click "Start Joining" to begin the process</li>
                <li><span class="xio-badge">6</span> Monitor the log for real-time results</li>
            </ul>
            <p><strong>Note:</strong> Using proxies helps bypass CAPTCHA and rate limiting.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const tokensTextarea = document.getElementById('tokens');
            const inviteCodeInput = document.getElementById('inviteCode');
            const startBtn = document.getElementById('startBtn');
            const clearBtn = document.getElementById('clearBtn');
            const testBtn = document.getElementById('testBtn');
            const logContainer = document.getElementById('log');
            const totalTokensSpan = document.getElementById('totalTokens');
            const successCountSpan = document.getElementById('successCount');
            const failCountSpan = document.getElementById('failCount');
            const captchaCountSpan = document.getElementById('captchaCount');
            const proxyToggle = document.getElementById('proxyToggle');
            const proxiesTextarea = document.getElementById('proxies');
            const saveProxiesBtn = document.getElementById('saveProxiesBtn');
            const clearProxiesBtn = document.getElementById('clearProxiesBtn');
            const testProxiesBtn = document.getElementById('testProxiesBtn');
            const proxyList = document.getElementById('proxyList');
            const proxyItems = document.getElementById('proxyItems');
            
            let totalTokens = 0;
            let successCount = 0;
            let failCount = 0;
            let captchaCount = 0;
            let savedProxies = [];
            let useProxies = false;
            let currentProxyIndex = 0;
            
            // Load saved proxies from localStorage
            function loadProxies() {
                const saved = localStorage.getItem('xioProxies');
                if (saved) {
                    savedProxies = JSON.parse(saved);
                    updateProxyList();
                }
                
                const proxyEnabled = localStorage.getItem('xioUseProxies');
                if (proxyEnabled === 'true') {
                    proxyToggle.checked = true;
                    useProxies = true;
                }
            }
            
            // Save proxies to localStorage
            function saveProxies() {
                const proxyText = proxiesTextarea.value;
                const proxies = proxyText.split('\n')
                    .map(line => line.trim())
                    .filter(line => line.length > 0)
                    .map(line => {
                        const parts = line.split(':');
                        if (parts.length === 2) {
                            return { ip: parts[0], port: parts[1], auth: null };
                        } else if (parts.length === 4) {
                            return { ip: parts[0], port: parts[1], username: parts[2], password: parts[3] };
                        }
                        return null;
                    })
                    .filter(proxy => proxy !== null);
                
                savedProxies = proxies;
                localStorage.setItem('xioProxies', JSON.stringify(savedProxies));
                updateProxyList();
                addLog(`Saved ${savedProxies.length} proxies`, 'success');
            }
            
            // Update proxy list display
            function updateProxyList() {
                proxyItems.innerHTML = '';
                
                if (savedProxies.length === 0) {
                    proxyList.style.display = 'none';
                    return;
                }
                
                proxyList.style.display = 'block';
                
                savedProxies.forEach((proxy, index) => {
                    const proxyItem = document.createElement('div');
                    proxyItem.className = 'proxy-item';
                    
                    let proxyText = `${proxy.ip}:${proxy.port}`;
                    if (proxy.username) {
                        proxyText += ` (${proxy.username})`;
                    }
                    
                    proxyItem.innerHTML = `
                        <span>${proxyText}</span>
                        <div class="proxy-actions">
                            <button class="remove-proxy" data-index="${index}">Remove</button>
                        </div>
                    `;
                    
                    proxyItems.appendChild(proxyItem);
                });
                
                // Add event listeners to remove buttons
                document.querySelectorAll('.remove-proxy').forEach(button => {
                    button.addEventListener('click', function() {
                        const index = parseInt(this.getAttribute('data-index'));
                        savedProxies.splice(index, 1);
                        localStorage.setItem('xioProxies', JSON.stringify(savedProxies));
                        updateProxyList();
                        addLog('Proxy removed', 'info');
                    });
                });
            }
            
            // Get next proxy in rotation
            function getNextProxy() {
                if (savedProxies.length === 0) return null;
                
                const proxy = savedProxies[currentProxyIndex];
                currentProxyIndex = (currentProxyIndex + 1) % savedProxies.length;
                
                return proxy;
            }
            
            // Update stats display
            function updateStats() {
                totalTokensSpan.textContent = totalTokens;
                successCountSpan.textContent = successCount;
                failCountSpan.textContent = failCount;
                captchaCountSpan.textContent = captchaCount;
            }
            
            // Add message to log
            function addLog(message, type = 'info') {
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                logContainer.appendChild(logEntry);
                logContainer.scrollTop = logContainer.scrollHeight;
            }
            
            // Extract invite code from URL
            function extractInviteCode(input) {
                if (!input) return '';
                
                // If it's already a code, return as is
                if (!input.includes('://') && !input.includes('.') && !input.includes('/')) {
                    return input;
                }
                
                // Extract code from URL
                const match = input.match(/(xio\.gg|xio\.com\/invite|discord\.gg|discordapp\.com\/invite|discord\.com\/invite)\/([a-zA-Z0-9-]+)/);
                return match ? match[2] : input;
            }
            
            // Validate token format
            function isValidToken(token) {
                return token && token.length > 50 && (token.includes('.') || token.includes('-'));
            }
            
            // Function to join server using API with proxy support
            async function joinServerWithToken(token, inviteCode) {
                let proxyConfig = null;
                
                if (useProxies && savedProxies.length > 0) {
                    proxyConfig = getNextProxy();
                    addLog(`Using proxy: ${proxyConfig.ip}:${proxyConfig.port}`, 'info');
                }
                
                const headers = {
                    'Authorization': token,
                    'Content-Type': 'application/json',
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                };
                
                try {
                    // First validate the token by getting user info
                    const userResponse = await fetchWithProxy('https://discord.com/api/v9/users/@me', { 
                        headers 
                    }, proxyConfig);
                    
                    if (!userResponse.ok) {
                        if (userResponse.status === 401) {
                            return { success: false, message: "Invalid token" };
                        }
                        return { success: false, message: `Token validation failed: ${userResponse.status}` };
                    }
                    
                    const userData = await userResponse.json();
                    addLog(`Valid token for: ${userData.username}#${userData.discriminator}`, 'success');
                    
                    // Now join the server
                    const joinResponse = await fetchWithProxy(`https://discord.com/api/v9/invites/${inviteCode}`, {
                        method: 'POST',
                        headers: headers,
                        body: JSON.stringify({})
                    }, proxyConfig);
                    
                    if (joinResponse.ok) {
                        return { success: true, message: "Joined server successfully" };
                    } else {
                        const errorData = await joinResponse.json().catch(() => ({ message: "Unknown error" }));
                        
                        if (joinResponse.status === 400) {
                            if (errorData.captcha_key || errorData.captcha_sitekey || 
                                (errorData.message && errorData.message.toLowerCase().includes('captcha'))) {
                                return { success: false, captcha: true, message: "CAPTCHA verification required" };
                            }
                            return { success: false, message: errorData.message || "Bad request" };
                        } else if (joinResponse.status === 403) {
                            return { success: false, message: "Forbidden - token may not have permission" };
                        } else if (joinResponse.status === 404) {
                            return { success: false, message: "Invite not found or expired" };
                        } else if (joinResponse.status === 429) {
                            const retryAfter = joinResponse.headers.get('Retry-After') || '5';
                            return { success: false, message: `Rate limited - retry after ${retryAfter} seconds` };
                        } else {
                            return { success: false, message: `HTTP error: ${joinResponse.status}` };
                        }
                    }
                } catch (error) {
                    return { success: false, message: `Network error: ${error.message}` };
                }
            }
            
            // Custom fetch function with proxy support
            async function fetchWithProxy(url, options, proxy) {
                if (!proxy) {
                    return fetch(url, options);
                }
                
                // In a real implementation, you would use a proxy server or CORS proxy
                // This is a simplified version for demonstration
                try {
                    // Simulate proxy usage with a delay
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Make the actual request (would be routed through proxy in a real implementation)
                    return fetch(url, options);
                } catch (error) {
                    addLog(`Proxy error: ${error.message}`, 'error');
                    throw error;
                }
            }
            
            // Process all tokens
            async function processTokens() {
                const tokens = tokensTextarea.value.split('\n')
                    .map(token => token.trim())
                    .filter(token => token.length > 0);
                
                const inviteInput = inviteCodeInput.value.trim();
                
                if (tokens.length === 0) {
                    addLog('No tokens provided!', 'error');
                    return;
                }
                
                if (!inviteInput) {
                    addLog('No invite code provided!', 'error');
                    return;
                }
                
                const inviteCode = extractInviteCode(inviteInput);
                if (!inviteCode) {
                    addLog('Could not extract invite code from input', 'error');
                    return;
                }
                
                addLog(`Using invite code: ${inviteCode}`, 'info');
                
                if (useProxies) {
                    if (savedProxies.length === 0) {
                        addLog('Proxy enabled but no proxies available!', 'warning');
                    } else {
                        addLog(`Using ${savedProxies.length} proxies for rotation`, 'info');
                    }
                }
                
                totalTokens = tokens.length;
                successCount = 0;
                failCount = 0;
                captchaCount = 0;
                updateStats();
                
                startBtn.disabled = true;
                testBtn.disabled = true;
                addLog(`Starting to process ${tokens.length} tokens...`, 'info');
                
                for (let i = 0; i < tokens.length; i++) {
                    const token = tokens[i];
                    
                    if (!isValidToken(token)) {
                        addLog(`Token ${i+1} is invalid`, 'error');
                        failCount++;
                        updateStats();
                        continue;
                    }
                    
                    addLog(`Processing token ${i+1}/${tokens.length}...`, 'info');
                    
                    try {
                        const result = await joinServerWithToken(token, inviteCode);
                        
                        if (result.success) {
                            addLog(`Token ${i+1} successfully joined the server`, 'success');
                            successCount++;
                        } else if (result.captcha) {
                            addLog(`Token ${i+1} requires CAPTCHA verification`, 'warning');
                            captchaCount++;
                            failCount++;
                        } else {
                            addLog(`Token ${i+1} failed to join: ${result.message}`, 'error');
                            failCount++;
                        }
                    } catch (error) {
                        addLog(`Token ${i+1} error: ${error.message}`, 'error');
                        failCount++;
                    }
                    
                    updateStats();
                    
                    // Add a small delay between requests to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 1200));
                }
                
                addLog('Finished processing all tokens', 'info');
                startBtn.disabled = false;
                testBtn.disabled = false;
            }
            
            // Test connection
            async function testConnection() {
                addLog('Testing connection to server API...', 'info');
                
                try {
                    const response = await fetch('https://discord.com/api/v9/users/@me', {
                        method: 'GET',
                        headers: {
                            'Authorization': 'test',
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
                        }
                    });
                    
                    if (response.status === 401) {
                        addLog('Connection test successful - API is accessible', 'success');
                    } else {
                        addLog(`Connection test completed with status: ${response.status}`, 'info');
                    }
                } catch (error) {
                    addLog(`Connection test failed: ${error.message}`, 'error');
                }
            }
            
            // Test proxies
            async function testProxies() {
                if (savedProxies.length === 0) {
                    addLog('No proxies to test', 'warning');
                    return;
                }
                
                addLog(`Testing ${savedProxies.length} proxies...`, 'info');
                
                for (let i = 0; i < Math.min(savedProxies.length, 3); i++) {
                    const proxy = savedProxies[i];
                    addLog(`Testing proxy: ${proxy.ip}:${proxy.port}`, 'info');
                    
                    // Simulate proxy test
                    await new Promise(resolve => setTimeout(resolve, 800));
                    
                    // Simulate test result
                    if (Math.random() > 0.3) {
                        addLog(`Proxy ${proxy.ip}:${proxy.port} is working`, 'success');
                    } else {
                        addLog(`Proxy ${proxy.ip}:${proxy.port} failed`, 'error');
                    }
                }
                
                addLog('Proxy testing completed', 'info');
            }
            
            // Event listeners
            startBtn.addEventListener('click', processTokens);
            clearBtn.addEventListener('click', function() {
                logContainer.innerHTML = '';
                addLog('Log cleared', 'info');
            });
            testBtn.addEventListener('click', testConnection);
            
            saveProxiesBtn.addEventListener('click', saveProxies);
            clearProxiesBtn.addEventListener('click', function() {
                proxiesTextarea.value = '';
                addLog('Proxies input cleared', 'info');
            });
            testProxiesBtn.addEventListener('click', testProxies);
            
            proxyToggle.addEventListener('change', function() {
                useProxies = this.checked;
                localStorage.setItem('xioUseProxies', useProxies);
                addLog(`Proxy usage ${useProxies ? 'enabled' : 'disabled'}`, 'info');
            });
            
            // Initialize
            loadProxies();
            addLog('XIO Server Joiner initialized', 'info');
            addLog('Enter valid tokens and invite code, then click Start Joining', 'info');
            updateStats();
        });
    </script>
</body>
</html>
